/***********************************************************************************************************************
* Copyright (c) , CVTE
* All rights reserved.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
* 文件    : PublicFunc.c
* 用途     : 公共模块函数
***********************************************************************************************************************/
#include "PublicFunc.h"
#include "TypeDef.h"
#include "Config.h"
#include "mcu_driver.h"

#if MODULE_PUBLICFUNC
/***********************************************************************************************************************
 功能：计算CRC16校验和
************************************************************************************************************************/
uint16_t PublicFunc_ComputeCRC16(uint8_t *Addr, uint8_t u8Len)
{
    uint16_t u16CRC = 0xffff;
    uint8_t i, j;

    for (j = 0; j < u8Len; j++)
    {
        u16CRC = u16CRC ^*Addr++;
        for (i = 0; i < 8; i++)
        {
            if((u16CRC & 0x0001) > 0)
            {
                u16CRC = u16CRC >> 1;
                u16CRC = u16CRC ^ 0xa001;
            }
            else
            {
                u16CRC = u16CRC >> 1;
            }
        }
    }
    return (u16CRC);
}

/***********************************************************************************************************************
 功能：比较计算当前状态值
************************************************************************************************************************/
uint8_t PublicFunc_CompareAndGetState(uint8_t sts, uint8_t tmp, const uint8_t *dt, uint8_t u8Len)
{
    uint8_t u8st_up = 0;
    uint8_t u8st_dn = 0;

    u8st_up = 0;        //上升判断用初始值
    u8st_dn = 0;        //下降判断用初始值
    while(u8Len--)
    {
        if ((char)tmp >= (char)*dt++)
        {
            ++u8st_dn;
        }
        if ((char)tmp >= (char)*dt++)
        {
            ++u8st_up;
        }
    }

    if (u8st_up > sts)
    {
        sts = u8st_up;
    }
    if (u8st_dn < sts)
    {
        sts = u8st_dn;
    }
    return (sts);
}



/***********************************************************************************************************************
 功能：温度领域值计算调用
************************************************************************************************************************/
int16_t PublicFunc_DomainDivision(int16_t i16Field, int16_t i16CurrTemp, int16_t *pi16DemarcationData, int16_t i16DemarcationDataSize, uint8_t u8ReturnDiff)
{
    int16_t i16TmpStWkUp = 0;                            //上升侧的变化值初始化
    int16_t i16TmpStWkDn = 0;                            //下降侧的变化值初始化
    while (i16DemarcationDataSize--)
    {
        //下降检测
        if (i16CurrTemp > (int16_t)((*pi16DemarcationData) * 10))
        {
            ++i16TmpStWkDn;
        }
        //上升检测
        if (i16CurrTemp > (int16_t)(((*pi16DemarcationData++) * 10) - u8ReturnDiff))
        {
            ++i16TmpStWkUp;
        }
    }

    //上升侧的变化值小于当前领域值
    if (i16TmpStWkUp < i16Field)
    {
        i16Field = i16TmpStWkUp;
    }
    //下降侧的变化值大于当前领域值
    if (i16TmpStWkDn > i16Field)
    {
        i16Field = i16TmpStWkDn;
    }

    return (i16Field);
}

/***********************************************************************************************************************
 功能：系统参数计算CheckSum
************************************************************************************************************************/
//bool_t PublicFunc_SysParaCheckSum(uint8_t *PSysparaBuf)
//{
//    uint8_t i = 0;
//    uint8_t u8Sum = 0;
//    bool_t u8Result = FALSE;

//    for (i = 0, u8Sum = 0; i < (PARAM_TABLE_SIZE - 1); i++)
//    {
//        u8Sum += PSysparaBuf[i];
//    }

//    u8Sum += 15;

//    if (u8Sum EQU PSysparaBuf[PARAM_TABLE_SIZE - 1])
//    {
//        u8Result = STATUS_TRUE;
//    }
//    else
//    {
//        u8Result = FALSE;
//    }

//    return u8Result;
//}
/***********************************************************************************************************************
* 功能：S16最大最小值限制处理
************************************************************************************************************************/
int16_t SubS16LimitCheck(int16_t s16Ttarget, int16_t s16TMin, int16_t s16TMax)
{
    if (s16Ttarget < s16TMin)
    {
        //目标频率小于最小值时
        return(s16TMin);
    }
    else if (s16Ttarget > s16TMax)
    {
        //目标频率大于最大值时
        return(s16TMax);
    }
    else
    {
        return(s16Ttarget);
    }
}
/***********************************************************************************************************************
* 功能：u16最大最小值限制处理
************************************************************************************************************************/
uint16_t SubU16LimitCheck(uint16_t u16Ttarget, uint16_t u16TMin, uint16_t u16TMax)
{
    if (u16Ttarget < u16TMin)
    {
        //目标频率小于最小值时
        return(u16TMin);
    }
    else if (u16Ttarget > u16TMax)
    {
        //目标频率大于最大值时
        return(u16TMax);
    }
    else
    {
        return(u16Ttarget);
    }
}
/***********************************************************************************************************************
* 功能：S8最大最小值限制处理
************************************************************************************************************************/
int8_t SubS8LimitCheck(int8_t s8Ttarget, int8_t s8TMin, int8_t s8TMax)
{
    if (s8Ttarget < s8TMin)
    {
        //目标频率小于最小值时
        return(s8TMin);
    }
    else if (s8Ttarget > s8TMax)
    {
        //目标频率大于最大值时
        return(s8TMax);
    }
    else
    {
        return(s8Ttarget);
    }
}
/***********************************************************************************************************************
* 功能：u8最大最小值限制处理
************************************************************************************************************************/
uint8_t SubU8LimitCheck(uint8_t u8Ttarget, uint8_t u8TMin, uint8_t u8TMax)
{
    if (u8Ttarget < u8TMin)
    {
        //目标频率小于最小值时
        return(u8TMin);
    }
    else if (u8Ttarget > u8TMax)
    {
        //目标频率大于最大值时
        return(u8TMax);
    }
    else
    {
        return(u8Ttarget);
    }
}
/***********************************************************************************************************************
* 功能：U8累加计数处理函数
************************************************************************************************************************/
void SubAddU8Cnt(uint8_t *pu8WkTime)
{
    if (*pu8WkTime < 0xFE)
    {
        (*pu8WkTime) ++;                    //计时变量计时
    }
    else
    {
        *pu8WkTime = 0xFE;                    //最大值赋值
    }
}

/***********************************************************************************************************************
* 功能：U16累加计数处理函数
************************************************************************************************************************/
void SubAddU16Cnt(uint16_t *pu16WkTime)
{
    if (*pu16WkTime < 0xFFFE)
    {
        (*pu16WkTime) ++;                    //计时变量计时
    }
    else
    {
        *pu16WkTime = 0xFFFE;                //最大值赋值
    }
}
/***********************************************************************************************************************
* 功能：U8递减计数处理函数
************************************************************************************************************************/
void SubDecU8Cnt(uint8_t *pu8WkTime)
{
    if (*pu8WkTime)
    {
        (*pu8WkTime) --;                        //计时变量计时
    }
}
/***********************************************************************************************************************
* 功能：U16递减计数处理函数
************************************************************************************************************************/
void SubDecU16Cnt(uint16_t *pu16WkTime)
{
    if (*pu16WkTime)
    {
        (*pu16WkTime) --;                        //计时变量计时
    }
}

/***********************************************************************************************************************
* 功能：Nop延时1us
************************************************************************************************************************/
static void PublicFunc_NopDelay_1us(void)
{
    uint16_t u16Tmp = 0;

    for (u16Tmp = 0; u16Tmp < 34; u16Tmp++)
    {
        {NOP_DELAY(); NOP_DELAY(); NOP_DELAY(); NOP_DELAY(); NOP_DELAY();}
    }
}

/***********************************************************************************************************************
* 功能：延时N us
************************************************************************************************************************/
void PublicFunc_Delay_us(uint32_t u32DelayTime)
{
    while (u32DelayTime--)
    {
        PublicFunc_NopDelay_1us();
    }
}

/***********************************************************************************************************************
* 功能：Nop延时1ms
************************************************************************************************************************/
static void PublicFunc_NopDelay_1ms(void)
{
    uint16_t u16Tmp = 0;

    for (u16Tmp = 0; u16Tmp < 340; u16Tmp++)
    {
        {NOP_DELAY(); NOP_DELAY(); NOP_DELAY(); NOP_DELAY(); NOP_DELAY();}
    }
}

/***********************************************************************************************************************
* 功能：延时N ms
************************************************************************************************************************/
void PublicFunc_Delay_ms(uint32_t u32DelayTime)
{
    while (u32DelayTime--)
    {
        PublicFunc_NopDelay_1ms();
    }
}


/***********************************************************************************************************************
* 功能：uint8_t温度类型放大10倍然后转换成int16_t温度类型计算处理
************************************************************************************************************************/
//int16_t PublicFunc_U8DataMultipleToS16Data(uint8_t u8TmpData)
//{
//    int16_t s16TmpData = 0;

//    s16TmpData = (int16_t)u8TmpData;
//    if (u8TmpData > 128)
//    {
//        s16TmpData = 0xFFFF - ((0x100 - s16TmpData) * MULTIPLE_10) + 1;
//    }
//    else
//    {
//        s16TmpData = s16TmpData * MULTIPLE_10;
//    }
//    return (s16TmpData);
//}



/***********************************************************************************************************************
* 功能：U16递减计数处理函数
************************************************************************************************************************/
int8_t Func_ValueRounding(int16_t s16Value)
{
    int8_t Result;

    if (s16Value > 0)
    {
        Result = (int8_t)((s16Value + 5) / 10);
    }
    else
    {
        Result = (int8_t)((s16Value - 5) / 10);
    }

    return Result;
}

#endif        /***Module End***/
/***********************************************************************************************************************
* * Copyright (c) , CVTE All rights reserved.  * * * END OF FILE
***********************************************************************************************************************/
